#!/usr/bin/env bash
Version_cptodrive="2.0.0"

# Get shared function
! source "SharedFunc" 2>/dev/null && echo "SharedFunc: No such file or directory" && exit 1

# Get color
color

git_dir_cptodrive="https://raw.githubusercontent.com/LHViet245/Easy-Manager/main/scripts/cptodrive"
script_name="$(basename "$0")"
source_path="$source_script/cptodrive"
cptodriveCOMP="$source_path/cptodriveCOMP.txt"
cptodriveDONE="$source_path/cptodriveDONE.txt"
cptodriveFAIL="$source_path/cptodriveFAIL.txt"
dir_config="$source_path/config"

[[ ! -d "$source_path" ]] && mkdir -p  "$source_path" && show_messenger "Created source script $source_path" "$script_name"
[[ ! -d "$dir_config" ]] && mkdir -p "$dir_config" && show_messenger "Created path config $dir_config" "$script_name"

# Progress like [P] 4/10 [C] 3/10 [F] 1/10
# [P] Current process
# [C] completed
# [F] Fail
function ShowProcess() {
	echo -ne "${Lightcyan}[P]${NC} ${Lightgray}${num_process}/${total_process}${NC}"
	[[ -n $num_check_COMP ]] && echo -ne " | ${Green}[C]${NC} ${Lightgray}${num_check_COMP}/${total_process}${NC}"
	[[ -n $num_check_FAIL ]] && echo -ne " | ${Red}[F]${NC} ${Lightgray}${num_check_FAIL}/${total_process}${NC}"
}

#Function Rclone
function copytodrive() {
    local subfolder
    num_check=$((num_check+1)) # count file process
    # Check file is Dicrectory or file
    if [[ -d "$1" ]] 2>/dev/null ;then
        # echo -e "\n${Yellow}[$filename]${NC} ${Blue}is a directory${NC}"
        subfolder="$filename"
    else
        subfolder=
    fi
    echo -ne "\n${Lightgreen}Start copying file${NC} ${Yellow}[$filename]${NC} ${Lightgreen}to Remote${NC} ${Yellow}[$drive_name:$root_folder]${NC} - "
    echo -ne "${Purple}[P]${NC} ${BWhite}$num_check/$((TotalFile-num_check_done))${NC}"
    [[ $num_check_comp -ne 0 ]] && echo -ne " | ${BGreen}[C]${NC} ${BWhite}$num_check_comp/$((TotalFile-num_check_done))${NC}"
    [[ $num_check_done -ne 0 ]] && echo -ne " | ${Lightyellow}[D]${NC} ${BWhite}$num_check_done/$TotalFile${NC}"
    [[ $num_check_fail -ne 0 ]] && echo -ne " | ${Red}[F]${NC} ${BWhite}$num_check_fail/$TotalFile${NC}"
    echo
    # Run Rclone
    if ! rclone copy --progress --progress-terminal-title "$1" "$drive_name:$root_folder/$subfolder" --fast-list --create-empty-src-dirs --ignore-existing --log-file="$log_rclone/log_rclone_$drive_name-$(date '+%d%m%Y').txt" --log-level DEBUG;then
        echo "$filename" >> "$cptodriveFAIL"
        num_check_fail=$((num_check_fail+1)) # count file fail
    else
        [[ "$first" == "yes" ]] && echo "---------------------------" >> "$cptodriveCOMP"
        echo "$filename" >> "$cptodriveCOMP"
        num_check_comp=$((num_check_comp+1)) # Count file comple
        first="no" # for the command to run only once in loop
    fi
}

# Get drive name
function config_drive_name_remote() {
local num=1
local choice
local remote

echo -e "\n${Orange}List remote:${NC}"
while IFS= read -r remote ;do
    local remote[$num]="$remote"
    if [[ $num -lt 10 ]]; then
			echo -e "\t\t ${BWhite}$num.${NC} ${Lightblue}${remote[$num]}${NC}"
	else
			echo -e "\t\t${BWhite}$num.${NC} ${Lightblue}${remote[$num]}${NC}"
	fi
    ((num++))
done < <(rclone listremotes | awk -F: '{print $1}')
echo -e "${Lightgray}Select the remote you want to use: ${NC}"
read -r choice
if [[ $choice -lt $num ]] && [[ $choice -ge 1 ]] && [[ "$choice" =~ ^[0-9]+$ ]] ;then
    num=$choice
    drive_name="${remote[$num]}"
    echo -e "${Yellow}[$drive_name]${NC} ${Lightblue}selected successfully${NC}\n"
else
    clear
    ERROR "Invalid choice"
    ERROR "Sorry! integers only or wrong number\nTRY AGAIN!!\n"
    config_drive_name_remote
fi
}

function config_root_folder() {
    local foldersub
    local foldersub_new
    local num
    local previous_directory
    local skip_loop="no"
    while true; do
        if [[ "$skip_loop" != "yes" ]] ;then
            num=1
            while IFS= read -r foldersub; do
                foldersub[$num]="$foldersub"
                if [[ $num -lt 10 ]]; then
                    echo -e "\t\t ${Lightgray}$num.${NC} ${Lightblue}${foldersub[$num]}${NC}"
                else
                    echo -e "\t\t${Lightgray}$num.${NC} ${Lightblue}${foldersub[$num]}${NC}"
                fi
                ((num++))
            done < <(rclone lsd "$drive_name:$root_folder" | awk -F '[0-9] ' '{print $NF}')
        fi

        # Show message if no folder in current directory
        if { [[ "$num" -lt 2 ]] && [[ ${#foldersub} -le 0 ]];} || [[ "$skip_loop" == "yes" ]];then 
            echo -e "${Purple}No directory found${NC}"
        fi 
        
        echo -e "\n${Orange}CURRENT DICRECROTY:${NC}  ${Cyan}'$drive_name:$root_folder'${NC}"
        echo -e "${Lightgray}Select Folder or type new folder in here.${NC}"
        echo -e "${Lightgray}Type 2 dot${NC} ${Cyan}'..'${NC} ${Lightgray}to go previous folder |${NC} ${BWhite}Enter blank to finish.${NC}"
        read -r foldersub_new
        [[ -z "$foldersub_new" ]] && echo -e "${BGreen}SUCCESS get root folder${NC} ${Yellow}'$drive_name:$root_folder'${NC}\n" && return 0
        if { [[ "$foldersub_new" -lt $num ]] && [[ "$foldersub_new" -ge 1 ]] && [[ "$foldersub_new" =~ ^[0-9]+$ ]];} 2>/dev/null; then
            num=$foldersub_new
            previous_directory="$root_folder"
            root_folder="$root_folder/${foldersub[$num]}"
    clear
            echo -e "${Yellow}[${foldersub[$num]}]${NC} ${Lightblue}selected successfully${NC}\n"
        elif [[ "$foldersub_new" == ".." ]] ;then
    clear
            echo -e "${Orange}Go Back${NC}\n" 
            root_folder="$previous_directory"
            previous_directory="$(echo "$root_folder" | sed -e's,^\(.*\/\).*,\1,g' | sed 's/.$//')"
            if ! rclone lsd "$drive_name:$root_folder" > /dev/null 2>&1 ;then
                skip_loop="yes"
            else
                skip_loop="no"
            fi
        else
            if [[ "$skip_loop" != "yes" ]];then
                    if [[ "${foldersub[*]}" =~ (^|[[:space:]])"$foldersub_new"($|[[:space:]]) ]] ;then
    clear
                        echo -e "${Yellow}Directory already exists. Will access this folder${NC}\n"
                        root_folder="$root_folder/$foldersub_new"
                        config_root_folder
                        return
                    fi
            fi
    clear
                previous_directory="$root_folder" 
                root_folder="$root_folder/$foldersub_new"
                echo -e "${Lightblue}Success create new folder${NC} ${Cyan}'$foldersub_new'${NC}\n"
                skip_loop="yes"
        fi
    done
}

function Custom_Config() {
    case "$1" in
        driveName )
            config_drive_name_remote
            ;;

        rootFolder)
            config_root_folder
            ;;
        
        * )
            Custom_Config "driveName"
            Custom_Config "rootFolder"
            ;;
    esac
}

function Setting {
    
    echo -e "\n${Yellow}Setting Default option - If it is 'no' then it will be asked for each run${NC}\n"
    case "$1" in
        dfRun )
            echo -e "${Lightgray}Default Run: ${NC}"
		    select Default_Run in "yes" "no" ;do show_messenger "Set Default Run: $Default_Run" "$script_name" && break ;done
           ;;

        ignore )
            echo -e "\n${Lightgray}Ignore Processed Video: ${NC}"
		    select Ignore_Processed in "yes" "no" ;do show_messenger "Set Ignore Processed Video: $Ignore_Processed" "$script_name" && break ;done
            ;;

		multiDrive )
			echo -e "\n${Lightgray}Multi Drive: ${NC}"
			echo -e "${Lightgray}This option will sync all selected drives${NC}"
			echo -e "${Lightgray}Options can only be changed in settings${NC}"
		    select Multi_Drive in "yes" "no" ;do show_messenger "Set Multi Drive: $Multi_Drive" "$script_name" && break ;done
			;;

		noask )
			echo -e "\n${Lightgray}Forced not to ask for options again after each run.${NC}"
		    select noAsk in "yes" "no" ;do show_messenger "Set Multi Drive: $noAsk" "$script_name" && break ;done
			;;

        * )
            Setting "dfRun"
            Setting "ignore"
            Setting "multiDrive"
            Setting "noask"
            ;;
    esac
    
}

function process_config() {
    case $1 in
        create_config ) # create new config file
			show_messenger "No config found" "$script_name"
            echo -e "${Lightgray}Synchronize config files with cloud (y/n) ?${NC}"
            if ask_user ;then
				echo -e "\n${Green}Will try searching on remote.${NC}"
				echo -e "${Lightgray}select the Remote you want to get the config file${NC}"
				Custom_Config "driveName"
				file_found="$(rclone ls "$drive_name:/config/$script_name" --include "*.config" 2>/dev/null | grep -c '\.config$')"
				if [[ $file_found -eq 0 ]] ;then
					echo -e "${Purple}No config found on remote${NC}"
					echo -e "${Green}Will create a new config file now${NC}"
					Custom_Config "All"
				else
					echo -e "\n${Orange}Found${NC} ${Cyan}$file_found${NC} ${Orange}config files on Remote${NC}\n"
					echo -e "${Lightgray}Will sync now....${NC}"
					! rclone copy --quiet --progress "$drive_name:/config/$script_name" "$dir_config" --fast-list --include "*.config" && ERROR "Sync ERROR! Check again!" "$script_name"
					echo -e "\n${Green}SYNC COMPLETE! Please run script again${NC}"
					exit 0
				fi
            else
				echo -e "${Green}Will create a new config.${NC}"
                Custom_Config "All"
			fi
            if [[ -n "${drive_name}" ]] && [[ -n "${root_folder}" ]] ;then
                Setting 'All'
            else
                WARNING "Drive name or Root folder not found. Please choose again" "$script_name"
                process_config "create_config"
            fi

			echo -e "${Lightgray}Enter the name you want to give the config file. No need${NC} ${Cyan}'.config'${NC} ${Lightgray}| Default name:${NC} ${Cyan}'$config_name'${NC}"
			echo -e "${Lightgray}If the config file has the same name as the existing file, it will be overwritten.${NC}"
            echo -e "${BWhite}Enter blank to set default name${NC}"
            read -r config_name1
            if [[ -n "${config_name1}" ]] ;then 
                if [[ "${config_name1##*.}" != "config" ]] ;then
                    config_name="${config_name1}.config"
                else
                    config_name="${config_name1}"
                fi
            else
                config_name="${drive_name}_$(echo "$root_folder" | awk -F '/' '{print $NF}')_$(date '+%d%m%Y').config"
            fi

            echo "[ DO NOT DELETE THE LEFT COLUMN 
      SPACE MUST NOT CHANGE     ]
==============CONFIG==============
Drive Name              :   ${drive_name}
Root Folder             :   ${root_folder}
==================================
[OPTION]
Default Run             :   ${Default_Run}
Ignore Processed file   :   ${Ignore_Processed}
Multi Dirve             :   ${Multi_Drive}
noAsk                   :   ${noAsk}" > "${dir_config}/${config_name}"

			if [[ "${Multi_Drive}" == "yes" ]] ;then
				echo "==================================
[Multi Drive]" > "${dir_config}/${config_name}"
			fi

			loaded_config="${dir_config}/${config_name}"
			loaded_config_name="$(basename "$loaded_config")"
			show_messenger "Config has been saved at '$loaded_config'" "$script_name"
		;;

		read_config ) # Need pass ${loaded_config}
			[[ ! -f "$loaded_config" ]] && ERROR "Cant load config! Config Not Found" "$script_name"

			loaded_config_name="$(basename "$loaded_config")"
			drive_name="$(grep -w '^Drive Name' "$loaded_config" | awk '{print $NF}' | sed 's/ //g')"
			root_folder="$(grep -w '^Root Folder' "$loaded_config" | awk '{print $NF}' | sed 's/ //g')"
			Default_Run="$(grep -w '^Ignore Processed file' "$loaded_config" | awk '{print $NF}' | sed 's/ //g')"
			Ignore_Processed="$(grep -w '^Ignore Processed file' "$loaded_config" | awk '{print $NF}' | sed 's/ //g')"
			Multi_Drive="$(grep -w '^Multi Dirve' "$loaded_config" | awk '{print $NF}' | sed 's/ //g')"
			noAsk="$(grep -w '^noAsk' "$loaded_config" | awk '{print $NF}' | sed 's/ //g')"
			
		;;

		handle_config )
			local filecfg
			local num_file
			local new_config
			num_file=1
			echo -e "${Orange}List Config: \n${NC}"
			while IFS= read -r filecfg ;do
				if [[ -f "$filecfg" ]] ;then
					if [[ "$(grep -w '^Default Run' "$filecfg" | awk '{print $NF}' | sed 's/ //g')" == "yes" ]] 2>/dev/null;then
						loaded_config="$filecfg"
						process_config "read_config"
						return 0
					else
						config_name[$num_file]="$(basename "$filecfg")"
						if [[ $num_file -lt 10 ]]; then
								echo -e "\t\t ${BWhite}$num_file.${NC} ${Lightblue}${config_name[$num_file]}${NC}"
						else
								echo -e "\t\t${BWhite}$num_file.${NC} ${Lightblue}${config_name[$num_file]}${NC}"
						fi
					fi
				fi
				((num_file++))
			done< <(find "$dir_config" -maxdepth 1 -type f -name "*.config" 2>/dev/null)

			echo -e "\n${Orange}Found${NC} ${Lightyellow}$((num_file - 1))${NC} ${Orange}config files${NC}\n"

			echo -e "${Lightgray}Select the config file you want to use.${NC}"
			echo -e "${Lightgray}Type${NC} ${Cyan}'config'${NC} ${Lightgray}to create a new config file.${NC}"
			echo -e "${Lightgray}Type${NC} ${Cyan}'show [number]'${NC} ${Lightgray}to see config file information. Eg.${NC} ${Cyan}'show 1'${NC}"
			echo -e "${Lightgray}Type${NC} ${Cyan}'rm [number]'${NC} ${Lightgray}to delete config file. Eg.${NC} ${Cyan}'rm 1'${NC}"
			echo -e "${BWhite}Enter blank will automatically load the first config file.${NC}"
			read -r new_config
			if { [[ "$new_config" -lt $num_file ]] && [[ "$new_config" -ge 1 ]] && [[ "$new_config" =~ ^[0-9]+$ ]];} 2>/dev/null; then
				num_file=$new_config
				loaded_config="$dir_config/${config_name[$num_file]}"
				if [[ "${noAsk}" != "yes" ]]; then	
					echo -e "${Lightgray}Set default this config file for next run? (y/n)${NC}"
					ask_user && sed -i '/^\(\s\|#\)*Default Run/ c\Default Run             :   yes' "$loaded_config"
				fi
				process_config "read_config"
			elif [[ -z "$new_config" ]] ;then
				num_file=1
				loaded_config="$dir_config/${config_name[$num_file]}"
				if [[ "${noAsk}" != "yes" ]]; then
					echo -e "${Lightgray}Set default this config file for next run? (y/n)${NC}"
					ask_user && sed -i '/^\(\s\|#\)*Default Run/ c\Default Run             :   yes' "$loaded_config"
				fi
				process_config "read_config"
			elif [[ "$new_config" == "config" ]] ;then
				process_config "create_config"
			elif [[ ${new_config:0:4} == "show" ]] && [[ $(echo "$new_config" | awk '{print $NF}') =~ ^[0-9]+$ ]] && [[ $(echo "$new_config" | awk '{print $NF}') -lt "$num_file" ]];then
				num_file=$(echo "$new_config" | awk '{print $NF}')
				loaded_config="$dir_config/${config_name[$num_file]}"
				clear
				echo -e "\n${Yellow}    !!! Press${NC} ${Lightyellow}Q${NC} ${Yellow}to Quit !!!${NC}"
				! less -X "$loaded_config" && clear && WARNING "File not found! Cannot Show file config" "$script_name" || clear
				process_config "handle_config"
			elif [[ ${new_config:0:2} == "rm" ]] && [[ $(echo "$new_config" | awk '{print $NF}') =~ ^[0-9]+$ ]] && [[ $(echo "$new_config" | awk '{print $NF}') -lt "$num_file" ]];then
				num_file=$(echo "$new_config" | awk '{print $NF}')
				loaded_config="$dir_config/${config_name[$num_file]}"
				! rm "$loaded_config" && clear && WARNING "File not found! Cannot delete file config" "$script_name" || clear
				echo
				show_messenger "Removed ${config_name[$num_file]}" "$script_name"
				process_config "handle_config"
			else
				echo -e "${Red}Invalid choice. Please chose again!\n${NC}"
				process_config "handle_config"
			fi
			
			show_messenger "Success load config [$loaded_config]" "$script_name"
		;;
	esac  
}

function CreateListFile() {
	local video
	while IFS= read -r video ;do
		filebasename "$video" || ERROR "Get file name error" "$script_name"
		if [[ -f "$video" ]] && CheckVideoDone || { [[ -f "$video" ]] && [[ "$skipFile" == "yes" ]]; } ;then
			list_video+=("$video")
		elif [[ -f "$video" ]] && ! CheckVideoDone ;then
			echo "$filename" >> "$cptodriveDONE"
			((num_check_DONE+=1))
		fi
	done < <(find "$1" -maxdepth 1 -type f \( -iname \*.mp4 -o -iname \*.mkv -o -iname \*.avi -o -iname \*.ts -o -iname \*.flv -o -iname \*.m4v -o -iname \*.mov -o -iname \*.wmv \))
	[[ $? -ne 0 ]] && ERROR "Create List Video need to handle is FAIL" "$script_name"
}

# Control rclone
function copytodriveAUTO() {

	listFile=()
	if [[ "${noAsk}" != "yes" ]]; then
		echo -e "${Lightgray}Copy all files including copied files (y/n)${NC}"
		ask_user && local skip_file="yes"
	fi
		echo -e "${Lightgray}Automatically create folders sorted by date? (y/n)${NC}"
		ask_user && root_folder="$root_folder/$(date '+%d-%m-%Y')"	
	clear

	if [[ $# -eq 0 ]] ;then



		FILECOUNT="$(find "$PWD"/* -maxdepth 0 -type f -printf x | wc -c)"
		DIRCOUNT="$(find "$PWD"/* -maxdepth 0 -type d -printf x | wc -c)"
		TotalFile="$(find "$PWD"/* -maxdepth 0 -printf x | wc -c)"
		echo -ne "\n${BGreen}CHECKED:${NC}  "
		if [[ $FILECOUNT -ne 0 ]] ;then
			echo -ne "${Lightgray}$FILECOUNT${NC} ${Purple}File${NC} | "
		fi
		if [[ $DIRCOUNT -ne 0 ]] ;then
			echo -ne "${Lightgray}$DIRCOUNT${NC} ${Purple}Directory${NC} | "
		fi
		echo -e "${BGreen}TOTAL:${NC} ${Lightgray}$TotalFile${NC}"
		for file in * ;do
			filename "$file"
			if [[ -e "$file" ]] 2>/dev/null;then
				#text=$(grep -wF "$filename" "$cptodriveCOMP")
				if { [[ $(grep -wFc "$filename" "$cptodriveCOMP") -ne 0 ]] && [[ "$skip_file" != "yes" ]];} 2>/dev/null ;then
					echo "$filename" >> "$cptodriveDONE"
					num_check_done=$((num_check_done+1))
				else
					# echo -e "\n${Lightblue}Confirm${NC} ${Yellow}[$filename]${NC} ${Lightblue}has not been copied to Remote${NC} ${Yellow}[$drive_name]${NC}"
					copytodrive "$file"
				fi
			fi
		done
	else
		for file in "$@" ;do
			if [[ -d $file ]] ;then
				DIRCOUNT=$((DIRCOUNT+1))
			else
				FILECOUNT=$((FILECOUNT+1))
			fi
				TotalFile=$#
		done
		echo -ne "\n${BGreen}CHECKED:${NC} "
		[[ $FILECOUNT -ne 0 ]] && echo -ne "${Lightgray}$FILECOUNT${NC} ${Purple}File${NC} | "
		[[ $DIRCOUNT -ne 0 ]] && echo -ne "${Lightgray}$DIRCOUNT${NC} ${Purple}Directory${NC} | "
		echo -e "${BGreen}TOTAL:${NC} ${Lightgray}$TotalFile${NC}"
		for file in "$@" ;do
			filename "$file"
			if [ -e "$file" ] ;then
				#text="$(grep -wF "$filename" "$cptodriveCOMP")"
				if { [[ $(grep -wFc "$filename" "$cptodriveCOMP") -ne 0 ]] && [[ "$skip_file" != "yes" ]];} 2>/dev/null ;then
					#echo -e "${Yellow}[$filename]${NC} ${Green}Da Copy Sang Drive${NC} ${Yellow}[vietle]${NC}"
					echo "$filename" >> "$cptodriveDONE"
					num_check_done=$((num_check_done+1))
				else
					# echo -e "${Lightblue}Confirm${NC} ${Yellow}[$filename]${NC} ${Lightblue}has not been copied to Remote${NC} ${Yellow}[$drive_name]${NC}\n"
					copytodrive "$file"
				fi
			else 
				echo -e "\n${Red}Does not exist${NC} ${Yellow}[$filename]${NC}"
				ERROR "Please Check Again\n"
				echo "$filename does not exist" >> "$cptodriveFAIL"
			fi
		done
	fi
	# List File Done or Completed or FAIL
	checkfile "$@"
}

function copytodrive() {
	local subfolder
	num_check=$((num_check+1)) # count file process
	# Check file is Dicrectory or file
	if [[ -d "$1" ]] 2>/dev/null ;then
		# echo -e "\n${Yellow}[$filename]${NC} ${Blue}is a directory${NC}"
		subfolder="$filename"
	else
		subfolder=
	fi
	echo -ne "\n${Lightgreen}Start copying file${NC} ${Yellow}[$filename]${NC} ${Lightgreen}to Remote${NC} ${Yellow}[$drive_name:$root_folder]${NC} - "
	echo -ne "${Purple}[P]${NC} ${BWhite}$num_check/$((TotalFile-num_check_done))${NC}"
	[[ $num_check_comp -ne 0 ]] && echo -ne " | ${BGreen}[C]${NC} ${BWhite}$num_check_comp/$((TotalFile-num_check_done))${NC}"
	[[ $num_check_done -ne 0 ]] && echo -ne " | ${Lightyellow}[D]${NC} ${BWhite}$num_check_done/$TotalFile${NC}"
	[[ $num_check_fail -ne 0 ]] && echo -ne " | ${Red}[F]${NC} ${BWhite}$num_check_fail/$TotalFile${NC}"
	echo
	# Run Rclone
	if ! rclone copy --progress --progress-terminal-title "$1" "$drive_name:$root_folder/$subfolder" --fast-list --create-empty-src-dirs --ignore-existing --log-file="$log_rclone/log_rclone_$drive_name-$(date '+%d%m%Y').txt" --log-level DEBUG;then
		echo "$filename" >> "$cptodriveFAIL"
		num_check_fail=$((num_check_fail+1)) # count file fail
	else
		[[ "$first" == "yes" ]] && echo "---------------------------" >> "$cptodriveCOMP"
		echo "$filename" >> "$cptodriveCOMP"
		num_check_comp=$((num_check_comp+1)) # Count file comple
		first="no" # for the command to run only once in loop
	fi
}

function checkfile() {
	local list
		## List File Completed
	if [[ -f "$cptodriveCOMP" ]] && [[ $num_check_comp -gt 0 ]] 2>/dev/null ;then
		echo -e "\n${BGreen}[COMPLETED]${NC}"
		while IFS= read -r list ;do
			if [[ "$list" == "---------------------------" ]] ;then
				if [[ $first == "no" ]] ;then
					echo -n "$list" ;echo -e "  ${Purple}Total $num_check_comp file${NC} | ${Orange}$(date '+%d-%m-%Y')${NC} | ${Lightgray}$(date '+%H:%M')${NC}"
					first="stop" # Stop 
				fi
			else
				echo -e "${Green}"$list"${NC}"
			fi
		done < <(tail -n $((num_check_comp + 2)) "$cptodriveCOMP") 2>/dev/null
	fi
		## List File Done
	if [[ -f "$cptodriveDONE" ]] 2>/dev/null ;then
		echo -e "\n${BYellow}[Done]${NC}"
		if [ $# -gt 15 ] 2>/dev/null ;then
			echo -e "${Purple}MORE....${NC}"
			while IFS= read -r list ;do
					echo -e "${Yellow}$list${NC}"
			done < <(tail -n 15 "$cptodriveDONE") 2>/dev/null
		else
			while IFS= read -r list ;do
					echo -e "${Yellow}$list${NC}"
			done < <(cat "$cptodriveDONE") 2>/dev/null
		fi
		rm "$cptodriveDONE" 2>/dev/null
	fi
		## List File Fail
	if [[ -f "$cptodriveFAIL" ]] 2>/dev/null ;then
		echo -e "\n${BRed}[FAIL]${NC}"
		while IFS= read -r list ;do
				echo -e "${Red}$list${NC}"
		done < <(cat "$cptodriveFAIL") 2>/dev/null
		rm "$cptodriveFAIL" 2>/dev/null
	fi
}

function menuRclone() {
echo -e "${Orange}                                      ${NC}${Lightcyan}Loaded              :${NC} ${BWhite}$loaded_config_name${NC}"
echo -e "${Orange}                                      ${NC}${Lightcyan}Drive Name          :${NC} ${BWhite}$drive_name${NC}"
echo -e "${Orange}   ****************************       ${NC}${Lightcyan}Root Folder         :${NC} ${BWhite}$root_folder${NC}"
echo -e "${Orange}   *    Copy Sync To Drive    *       ${NC}${Lightcyan}Deafault Run        :${NC} ${BWhite}$Default_Run${NC}"
echo -e "${Orange}   ****************************       ${NC}${Lightcyan}Ignore_Processed    :${NC} ${BWhite}$Ignore_Processed${NC}"
echo -e "${Orange}         Version $Version_cptodrive                ${NC}${Lightcyan}Multi Drive    :${NC} ${BWhite}$Multi_Drive${NC}"
echo -e "${Orange}                                      ${NC}${Lightcyan}No Ask Option       :${NC} ${BWhite}$noAsk${NC}"

echo -e "\n${BWhite}Main Menu: What would you like to do?${NC}\n"
echo -e "${BWhite}Press the number of your choice:${NC}\n"
echo -e "${BWhite}	1 - Default copy to root folder -${NC} ${Cyan}$drive_name:$root_folder${NC}"
echo -e "${BWhite}	2 - Create more folders in the root folder -${NC} ${Cyan}$drive_name:$root_folder/FOLDER_HERE/${NC}"
echo -e "${BWhite}	3 - Copy files by extension .EG:${NC} ${Cyan}srt | mp4 | mp3 | txt | jpeg ...${NC}"
echo -e "${BWhite}	4 - Reset default config file.${NC}"
echo -e "${BWhite}	5 - Sync the config file to the current drive .${NC}"
echo -e "${BWhite}	6 - Update version.${NC}"
echo -e "${BWhite}	0 - Exit${NC}"

# Wait for user to make a choice and run chosen functions:	
read -r -n 1 -s choice;

case $choice in 
		
		1 )	# Copy File Sang Drive Mac Dinh /syncc/
clear
			#echo -e "\n---------------------------" >> "$cptodriveCOMP"
			copytodriveAUTO "$@"
		
		;;
		
		2 )  # Tao Thu Muc Dich Den /syncc/FOLDER_HERE/""
clear
			#echo -e "\n---------------------------" >> "$cptodriveCOMP"
			local folder
			echo -e "${Lightgray}Name of the folder you want to create: ${NC}"
			echo -e "${Lightgray}Can create multiple paths. EG:${NC} ${Cyan}dir1/dir2/dir3${NC}"
			read -r folder
			[[ -n "$folder" ]] 2>/dev/null && root_folder="$root_folder/$folder" && echo -e "${Green}Success creates a new path${NC} ${Yellow}[$drive_name:$root_folder]${NC}"
			copytodriveAUTO "$@"
	
		;;
		
		3 )	# Chi Copy File Subtitle .srt
clear	
			local file_extension
			local file_extension_input
			local folder
			local extension
			local arg
			file_extension=()
			#echo -e "\n---------------------------" >> "$cptodriveCOMP"
			echo -e "${Lightgray}Enter the name of the extension file you want to copy to the remote drive ${NC}"
			echo -e "${Lightgray}Enter only the filename extension, no dot${NC} ${Cyan}' . '${NC}"
			echo -e "${Lightgray}Enter the file format extension name one by one${NC}"
			echo -e "${Lightgray}Eg:${NC} ${Cyan}srt | mp4 | mp3 | txt${NC}"
			while IFS= read -r file_extension_input; do
				[[ -z "$file_extension_input" ]] && echo -e "${Green}Successfully added file extension${NC}" && break  # break if line is empty
				file_extension_input="$(echo "$file_extension_input" | sed 's/ //g')"
				file_extension+=("$file_extension_input")
				echo -e "${Lightgray}Next extension (end with an empty line): ${NC}"
				echo -ne "${Lightgray}Added: ${NC}";IFS=',';echo -e "${Cyan}${file_extension[*]// /,}${NC}";IFS=$' \t\n'
			done
			echo -e "${Lightgray}Name of the folder you want to create more in${NC} ${Cyan}'$drive_name:$root_folder'${NC}"
			echo -e "${Lightgray}Can create multiple paths. EG:${NC} ${Cyan}dir1/dir2/dir3${NC}"
			read -r folder
			[[ -n "$folder" ]] && root_folder="$root_folder/$folder"
			echo -e "${Lightgray}Copy all files including copied files (y/n)${NC}"
			ask_user && local skip_file="yes"
			if [[ $# -eq 0 ]] ;then
				echo -ne "\n${BGreen}CHECKED:${NC}  "
				for extension in "${file_extension[@]}" ;do
					local total[$extension]="$(find "$PWD"/*."$extension" -maxdepth 0 -type f -printf x 2>/dev/null | wc -c)"
					TotalFile=$(( TotalFile+${total[$extension]} ))
					echo -ne "${Lightgray}${total[$extension]}${NC} ${Lightcyan]}$extension${NC} | "
				done
				echo -e "${BGreen}TOTAL:${NC} ${Lightgray}$TotalFile${NC}"
				for extension in "${file_extension[@]}" ;do
					while IFS= read -r file ;do
						if [[ -f "$file" ]] ;then
							filename "$file"
							if { [[ $(grep -wFc "$filename" "$cptodriveCOMP") -ne 0 ]] && [[ "$skip_file" != "yes" ]];} 2>/dev/null ;then
								echo "$filename" >> "$cptodriveDONE"
								num_check_done=$((num_check_done+1))
							else
								copytodrive "$file"
							fi
						fi
					done< <(find . -type f -name "*.$extension")
				done 
			else
				for arg in "$@" ;do
					if [[ -d "$arg" ]] ;then	
						echo -ne "${BGreen}$arg:${NC}  "
						local TotalFileSinge=0
						for extension in "${file_extension[@]}" ;do
							local total[$extension]="$(find "$(readlink -f "$arg")"/*."$extension" -maxdepth 0 -type f -printf x 2>/dev/null | wc -c)"
							local TotalFileSinge=$(( TotalFileSinge+${total[$extension]} ))
							echo -ne "${Lightgray}${total[$extension]}${NC} ${Lightcyan}$extension${NC} | "
						done
						TotalFile=$((TotalFile+TotalFileSinge))
						echo -e "${BGreen}TOTAL:${NC} ${Lightgray}$TotalFileSinge${NC}"
					else
						echo -e "${Yellow}[$arg]${NC} ${Red}is not dicrectory${NC}"
					fi
				done
				echo -e "\n${BPurple}CHECKED TOTAL:${NC} ${Lightgray}$TotalFile${NC} ${BPurple}FILE${NC}"
				for arg in "$@" ;do
					if [[ -d "$arg" ]];then
						for extension in "${file_extension[@]}" ;do
							while IFS= read -r file ;do
								if [[ -f "$file" ]] ;then
									filename "$file"
									if { [[ $(grep -wFc "$filename" "$cptodriveCOMP") -ne 0 ]] && [[ "$skip_file" != "yes" ]];} 2>/dev/null ;then
										echo "$filename" >> "$cptodriveDONE"
										num_check_done=$((num_check_done+1))
									else
										copytodrive "$file"
									fi
								fi
							done< <(find "$(readlink -f "$arg")" -type f -name "*.$extension")
						done
					fi
				done
			fi
			checkfile
		;;

		4 ) # Reset setting
			echo -e "\n${Lightgray}Are you sure to reset the config file? or Setting new config (y/n)${NC}"
			ask_user && sed -i '/^\(\s\|#\)*Default run/ c\Default run : NO' "$dir_filecfg"
			"$0" "$@"
		;;

		5 ) # Sync the config file to the current drive
			echo -e "\n${Lightgray}Default will be saved at${NC} ${Cyan}$drive_name:/config/$(echo "$script_name" | tr -d '.')${NC}"
			echo -e "${Lightgray}Do you want to sync now? (y/n)${NC}"
			if ask_user ;then
				root_folder="/config/$(echo "$script_name" | tr -d '.')"
				while IFS= read -r file ;do
					if [[ -f "$file" ]] ;then
						filename "$file"
						copytodrive "$file"
					fi
				done< <(find "$config_file" -type f -name '*.config') 2>/dev/null
				checkfile

			else
				menuRclone "$@"
			fi
		;;

		6 ) # Update Script
			if testvercomp "$new_version" "$version" ">" 2>/dev/null;then
				if ! curl -o "$(dirname "$(readlink -f "$0")")/$script_name" "https://raw.githubusercontent.com/LHViet245/Script-Auto-Manager/main/scripts/.cptodrive-new" 2>/dev/null ;then
					ERROR "Upgrade failed. Upgrade download failed!"
					exit 1
				else
					chmod +x "$(dirname "$(readlink -f "$0")")/$script_name"
					echo -e "${Green}Successful upgrade version${NC} ${Lightgray}'$new_version'${NC}${Green}. You can use it now!${NC}"
					exit 0
				fi
			else
				echo -e "${Green}You are using the latest version${NC} ${Lightgray}'$new_version'${NC}"
				menuRclone "$@"
			fi
		;;

		0 ) #Exit
clear
			echo -e "${Lightblue}Exited${NC}"
			return 0
		;;
		
		* ) # Not Valid Choice
clear
			ERROR "\nNot a valid choice"
			ERROR "Please choice some number\n"
			menuRclone "$@"
		;;
		
	esac

}

###############################################################################################
######################################## RUNNING SCRIPT #######################################

which rclone >/dev/null || ERROR "Rclone is not installed. Please make sure it's already installed." "$script_name"

if [[ "$(find "$dir_config" -maxdepth 1 -type f -name '*.config' | wc -c)" -eq 0 ]] ;then
	process_config "create_config"
else
	process_config "handle_config"
fi

menuRclone "$@"

echo -e "\n${Lightgray}DONE ALL${NC}"
echo -e "${Lightgray}THANK YOU FOR USING!${NC}"